#include<iostream>
#include<algorithm>
#include<vector>
#include<string>

using namespace std;

int maxCoin;
int k;
int cache[101][10001];
int undivide = numeric_limits<int>::max()-100000; //100000을 안더하면 26행에서 1을 더해주면 max에서 오버플로우가 생겨 -의 최대값이 되버림

vector<int> v;

int count(int n , int k)
{
	if (n == maxCoin)
		return (k == 0 ? 0 : undivide);
	
	int &ret = cache[n][k];
	if (ret != -1)
		return ret;

	ret = count(n + 1, k);
	if (k >= v[n])
		ret = min(ret, count(n, k - v[n]) + 1);

	return ret;
}

int main(int argc, char *argv[])
{

	cin >> maxCoin;
	cin >> k;
	
	for (int i = 0; i < 101; i++)
	for (int j = 0; j < 10001; j++)
		cache[i][j] = -1;
	
	for (int i = 0; i < maxCoin; i++)
	{
		int tmp;
		cin >> tmp;
		v.push_back(tmp);
	}
	
	int result = count(0, k);

	if (result == undivide)
		cout << "-1" << endl;
	else
		cout << result << endl;

	return 0;
}
